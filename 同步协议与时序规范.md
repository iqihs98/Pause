
# SYNC_SPEC.md

## iOS ↔ watchOS 同步规范（WatchConnectivity）

**版本**：v1.0
**适用范围**：MVP（会话状态同步 + 心率上传 + 会话总结归档）
**通道**：WatchConnectivity（WCSession）
**更新时间**：2026-01

---

## 1. 目标与原则（Goals & Principles）

### 1.1 同步目标

* iOS 与 watchOS 对同一个 `sessionId` 的 **会话状态一致**（Started/Paused/Finished）
* iOS 能持续接收心率样本并展示
* 断线后可**恢复**：至少保证会话总结最终归档到 iOS
* 避免重复/乱序消息造成 UI 抖动或错误统计

### 1.2 设计原则

* **iOS 为最终归档端**（Single Source of Truth for persistence）
* **watch 为心率采集端**（Single Source of Truth for heart rate）
* 消息必须**幂等**：重复到达不应改变最终结果
* 消息必须**可版本化**：允许未来新增字段/类型

---

## 2. 角色与责任（Roles & Responsibilities）

### 2.1 iOS 端职责

* 发起会话（可选主模式）
* 接收 watch 的心率样本与会话总结
* 持久化 Session / Summary / Samples（按策略）
* 提供历史查询

### 2.2 watchOS 端职责

* 展示呼吸动画（可独立发起或被动跟随）
* 使用 HealthKit 采集心率
* 发送心率样本与会话总结给 iOS
* 保证在离线时“最终可达”（至少 Summary）

---

## 3. 会话标识与时间模型（Session & Time Model）

### 3.1 sessionId 生成

* `sessionId` 使用 UUID
* **发起方生成**：

  * iOS 发起 → iOS 生成 `sessionId`
  * watch 发起 → watch 生成 `sessionId`

### 3.2 时间戳与漂移

* 所有消息均带：

  * `timestamp`：发送端本地 `Date().timeIntervalSince1970`（秒）
  * `seq`：会话内单调递增整数（用于强幂等与乱序处理）
* **状态同步采用“绝对起点 + elapsed”策略**（减少漂移）：

  * 推荐在 `session_state` 中携带 `startEpoch` 和 `elapsedMs`
  * 另一端以 `startEpoch + elapsed` 计算 remaining

> MVP 简化：也可只传 `remainingSeconds`，但漂移风险更高；本规范给出推荐字段。

---

## 4. 消息总览（Message Types）

### 4.1 通用消息封装

所有消息统一结构：

```json
{
  "type": "string",
  "sessionId": "UUID",
  "timestamp": 1700000000,
  "seq": 1,
  "payload": { },
  "version": "1.0"
}
```

字段说明：

* `type`：消息类型
* `sessionId`：会话 ID
* `timestamp`：发送时刻（秒）
* `seq`：会话内序号（每发送一次+1）
* `payload`：类型相关数据
* `version`：协议版本

---

### 4.2 类型列表

| type                | 方向                    | 说明                              | 实时性 |
| ------------------- | --------------------- | ------------------------------- | --- |
| `session_state`     | iOS→watch / watch→iOS | 会话状态（start/pause/resume/finish） | 高   |
| `heart_rate_sample` | watch→iOS             | 心率采样点                           | 高   |
| `session_summary`   | watch→iOS 或 iOS→watch | 会话结束总结（用于归档）                    | 中   |
| `hello`             | 双向                    | 握手（可选）                          | 低   |
| `resync_request`    | 双向                    | 请求对方发送最新状态/总结                   | 中   |

---

## 5. 具体消息格式（Schemas）

### 5.1 session_state

```json
{
  "type": "session_state",
  "sessionId": "UUID",
  "timestamp": 1700000000,
  "seq": 3,
  "payload": {
    "state": "started | paused | resumed | finished",
    "pattern": { "inhale": 4, "hold": 2, "exhale": 6 },
    "durationSec": 180,

    "startEpoch": 1700000000,
    "elapsedMs": 45000,

    "remainingSec": 135
  },
  "version": "1.0"
}
```

**说明**

* `pattern`、`durationSec`：仅在 started/resumed 时需要（用于跟随端重建会话）
* `startEpoch` + `elapsedMs`：推荐用于校准
* `remainingSec`：可作为 UI 显示与兜底

---

### 5.2 heart_rate_sample (watch → iOS)

```json
{
  "type": "heart_rate_sample",
  "sessionId": "UUID",
  "timestamp": 1700000005,
  "seq": 20,
  "payload": {
    "bpm": 68,
    "sampleEpoch": 1700000005
  },
  "version": "1.0"
}
```

**采样建议**

* 频率：1–2 秒/次（依据 HealthKit 回调能力）
* 若短暂中断：允许缺失，不需要补齐插值

---

### 5.3 session_summary

```json
{
  "type": "session_summary",
  "sessionId": "UUID",
  "timestamp": 1700000120,
  "seq": 999,
  "payload": {
    "startEpoch": 1700000000,
    "endEpoch": 1700000120,
    "durationSec": 120,

    "avgHeartRate": 65,
    "minHeartRate": 60,
    "maxHeartRate": 72,

    "sampleCount": 110
  },
  "version": "1.0"
}
```

**说明**

* `session_summary` 是**最终归档所需的最小集**
* 即使实时样本没传完，也要保证 summary 最终能到 iOS

---

## 6. 传输通道策略（Transport Strategy）

### 6.1 优先级与 API 选择

| 需求                       | 推荐 API                                                         | 原因     |
| ------------------------ | -------------------------------------------------------------- | ------ |
| 实时状态 `session_state`     | `sendMessage`                                                  | 低延迟    |
| 实时心率 `heart_rate_sample` | `sendMessage`                                                  | 低延迟    |
| 会话总结 `session_summary`   | `transferUserInfo`（或 `transferCurrentComplicationUserInfo` 如需） | 离线最终可达 |
| resync 请求                | `sendMessage`                                                  | 需要立即响应 |

### 6.2 sendMessage 失败策略

* 若 `sendMessage` 失败：

  * 对于 **state**：缓存最新 state，等 reachable 再发（只保留“最新一条”）
  * 对于 **heart_rate_sample**：可以丢弃（MVP 允许），或做小缓存（例如最近 10 条）
  * 对于 **summary**：必须改用 `transferUserInfo` 确保最终到达

---

## 7. 幂等与乱序处理（Idempotency & Ordering）

### 7.1 幂等键

对每个 session，接收端维护：

* `lastSeqByType[type]`（每种消息类型最后接收的 seq）
* 或更严格：`seenSeqSet`（但会增内存，不建议 MVP）

**规则**

* 若 `seq <= lastSeqByType[type]` → 丢弃（重复或乱序过旧）
* 否则接收并更新 `lastSeqByType[type] = seq`

### 7.2 状态消息乱序

* `session_state` 若乱序抵达：

  * 依赖 `seq` 判定最新
  * 同时可用 `elapsedMs` 作兜底：若 seq 异常但 elapsed 更大，可接受（可选）

### 7.3 summary 覆盖策略

* `session_summary` 只接受**第一条**或接受**更晚 endEpoch** 的一条（推荐后者）：

  * 若已存在 summary：

    * 新 summary 的 `endEpoch <= old.endEpoch` → 丢弃
    * 否则覆盖

---

## 8. 会话冲突与仲裁（Conflict Resolution）

### 8.1 同时发起冲突（iOS 与 watch 同时 start）

**MVP 简化仲裁规则**

* 每个端维护 `activeSessionId`（最多一个进行中）
* 当收到 started 且本端也 started：

  * 比较 `timestamp`：

    * 较早者胜出（Winner）
    * 败者停止本地会话并跟随 Winner（或提示用户）
* 记录日志便于排查

> 更严格可以引入 `origin = ios|watch` + `priority`，但 MVP 先用 timestamp 即可。

### 8.2 多会话并发

MVP 限制：**同一时间仅允许一个 active session**
接收到非 active 的消息：

* 若是 summary：仍可保存（历史）
* 若是 sample/state：忽略或仅用于历史（不建议）

---

## 9. 断线与恢复（Offline & Resync）

### 9.1 断线场景

* Watch 在会话中途与 iOS 失联
* iOS 在会话中途进入后台或不可达

### 9.2 恢复目标

* 恢复后 iOS 至少拿到 `session_summary`
* 可选：恢复后补发最后一个 `session_state`（让 UI 收敛）

### 9.3 resync_request

当一端重新 reachable：

* 发送 `resync_request`（sendMessage）
* 对方回应：

  * 若有 active session：回发最新 `session_state`
  * 若最近 1 个 session 已结束但 summary 未确认：重发 `session_summary`（transferUserInfo 也可）

```json
{
  "type": "resync_request",
  "sessionId": "UUID-or-empty",
  "timestamp": 1700000200,
  "seq": 1,
  "payload": {
    "want": ["session_state", "session_summary"],
    "activeSessionId": "UUID-or-null",
    "lastKnownSeq": { "session_state": 10, "heart_rate_sample": 80 }
  },
  "version": "1.0"
}
```

---

## 10. UI 同步一致性策略（Consistency）

### 10.1 倒计时与进度收敛

推荐以 `startEpoch + elapsedMs` 计算进度，避免两端 Timer 漂移：

* 发送端每隔 N 秒（例如 2–5 秒）发送一次 `session_state` 校准包
* 接收端收到后：

  * 若差值 ≤ 1 秒：平滑调整 UI（不跳变）
  * 若差值 > 1 秒：立即校正 remaining（允许一次跳变）

### 10.2 心率展示

* iOS UI 显示“最新 bpm”
* 若超过 5 秒未收到新 sample：

  * UI 显示 “--” 或 “信号弱”
  * 不停止会话

---

## 11. 安全与隐私（Privacy）

* 心率属于敏感数据：只在会话期间传输与展示
* MVP 默认本地存储（iOS）
* 不上传云端、不做第三方分析（除非后续明确加入）

---

## 12. 版本升级（Versioning）

* `version` 字段使用 `"1.0"` 字符串
* 向后兼容原则：

  * 新增字段：接收端忽略未知字段
  * 新增 type：旧版本直接忽略
* 破坏性变更：提升主版本 `"2.0"`

---

## 13. 实施清单（Implementation Checklist）

* [ ] 定义消息编码/解码（Dictionary / Codable JSON）
* [ ] 双端维护 `seq`（每个 session 单调递增）
* [ ] 接收端实现 `lastSeqByType` 幂等过滤
* [ ] `session_summary` 使用 `transferUserInfo` 保底
* [ ] reachable 变化监听：触发 resync_request
* [ ] 断线时缓存 “最新 state” 与 “summary 未确认” 标记
* [ ] iOS SessionStore 保存 summary（与可选 samples）

---

## 14. 附录：最小可用策略（MVP 简化版）

如果你希望先快速跑通：

* `session_state` 只传：state + remainingSec + pattern + durationSec
* 不做 `elapsedMs` 校准
* 不实现 `resync_request`
* 仍然保留：

  * `session_summary` 用 `transferUserInfo`
  * `seq` 幂等过滤（强烈建议别省）
