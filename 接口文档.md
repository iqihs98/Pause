# INTERFACES.md

## 模块接口契约（Swift Protocols & Contracts）

**版本**：v1.0
**范围**：MVP（呼吸引擎 + Watch 心率 + iOS 存储 + iOS/watch 同步）
**约束**：SharedKit 禁止依赖 HealthKit / WatchConnectivity / UIKit / WatchKit
**更新时间**：2026-01

---

## 0. 约定（Conventions）

### 0.1 Actor / 线程约束

* UI 层与 ViewModel：`@MainActor`
* SharedKit 引擎：推荐 `@MainActor`（MVP 简化）或 `actor`（更严谨）
* Connectivity 与 Store：建议使用 `actor` 串行化处理（避免并发写入/乱序）

### 0.2 命名与可测试性

* 所有 Service 用 protocol 抽象，便于 mock
* Engine 不持有 Timer，时间推进通过可注入 clock / tick 驱动（或内部实现但必须可测试）

---

## 1. SharedKit（Domain）接口

### 1.1 数据模型（Domain Models）

```swift
public struct BreathingPattern: Sendable, Codable, Equatable {
    public var inhale: TimeInterval
    public var hold: TimeInterval
    public var exhale: TimeInterval
}

public struct HeartRateSample: Sendable, Codable, Equatable {
    public var timestamp: Date
    public var bpm: Int
}

public struct BreathingSession: Sendable, Codable, Equatable {
    public var id: UUID
    public var startTime: Date
    public var endTime: Date?
    public var pattern: BreathingPattern
    public var duration: TimeInterval
}

public struct SessionSummary: Sendable, Codable, Equatable {
    public var sessionId: UUID
    public var startTime: Date
    public var endTime: Date
    public var duration: TimeInterval
    public var avgHeartRate: Double?
    public var minHeartRate: Int?
    public var maxHeartRate: Int?
    public var sampleCount: Int
}
```

> 说明：`avg/min/max` 允许为 nil（无心率模式或心率采集失败）。

---

### 1.2 引擎状态与事件（理解 UI 与同步需要什么）

```swift
public enum BreathingPhase: String, Sendable, Codable {
    case inhale, hold, exhale
}

public enum EngineLifecycle: String, Sendable, Codable {
    case idle, running, paused, finished
}

public struct BreathingEngineState: Sendable, Codable, Equatable {
    public var lifecycle: EngineLifecycle
    public var phase: BreathingPhase?
    public var phaseProgress: Double          // 0.0 ~ 1.0
    public var remainingSeconds: Int
    public var sessionId: UUID?
    public var pattern: BreathingPattern?
    public var durationSeconds: Int?
}

public enum BreathingEngineEvent: Sendable, Codable, Equatable {
    case didStart(session: BreathingSession)
    case didPause(sessionId: UUID)
    case didResume(sessionId: UUID)
    case didFinish(summary: SessionSummary)
    case tick(state: BreathingEngineState)
}
```

---

### 1.3 BreathingEngine 协议（Shared 核心）

```swift
@MainActor
public protocol BreathingEngineProtocol: AnyObject {
    var state: BreathingEngineState { get }

    /// 状态变化流（给 UI 与同步层订阅）
    var stateStream: AsyncStream<BreathingEngineState> { get }

    /// 事件流（用于日志/统计/结束总结触发）
    var eventStream: AsyncStream<BreathingEngineEvent> { get }

    func configure(pattern: BreathingPattern, durationSeconds: Int)

    /// 开始会话：若外部传入 sessionId，表示“跟随端”或“恢复会话”
    func start(sessionId: UUID?)

    func pause()
    func resume()
    func stop()

    /// 可选：外部 tick（方便测试/统一时钟）；如果 engine 内部有 Timer，可不实现
    func advance(by delta: TimeInterval)
}
```

**契约说明**

* `configure` 必须在 `start` 前调用（或 start 内部校验并抛错）
* `stop` 表示用户提前结束，也会进入 `finished` 并产出 summary（duration 以实际结束时间为准）

---

### 1.4 心率统计器（可选，但强烈建议独立）

```swift
public protocol HeartRateStatsProtocol: Sendable {
    mutating func add(_ sample: HeartRateSample)
    func summary(sessionId: UUID, start: Date, end: Date) -> SessionSummary
}
```

---

## 2. 同步消息层（Connectivity Contracts）

### 2.1 消息模型（与 SYNC_SPEC 对齐）

```swift
public enum SyncMessageType: String, Sendable, Codable {
    case sessionState = "session_state"
    case heartRateSample = "heart_rate_sample"
    case sessionSummary = "session_summary"
    case hello
    case resyncRequest = "resync_request"
}

public struct SyncEnvelope<Payload: Codable & Sendable>: Sendable, Codable {
    public var type: SyncMessageType
    public var sessionId: UUID
    public var timestamp: TimeInterval   // epoch seconds
    public var seq: Int
    public var payload: Payload
    public var version: String
}
```

---

### 2.2 Payload 定义

```swift
public struct SessionStatePayload: Sendable, Codable {
    public enum State: String, Sendable, Codable { case started, paused, resumed, finished }

    public var state: State
    public var pattern: BreathingPattern?
    public var durationSec: Int?

    public var startEpoch: TimeInterval?
    public var elapsedMs: Int?
    public var remainingSec: Int?
}

public struct HeartRateSamplePayload: Sendable, Codable {
    public var bpm: Int
    public var sampleEpoch: TimeInterval
}

public struct SessionSummaryPayload: Sendable, Codable {
    public var startEpoch: TimeInterval
    public var endEpoch: TimeInterval
    public var durationSec: Int
    public var avgHeartRate: Double?
    public var minHeartRate: Int?
    public var maxHeartRate: Int?
    public var sampleCount: Int
}

public struct ResyncRequestPayload: Sendable, Codable {
    public var want: [SyncMessageType]
    public var activeSessionId: UUID?
    public var lastKnownSeq: [SyncMessageType: Int]
}
```

---

### 2.3 ConnectivityClient/Host 协议（双端通用抽象）

> iOS/watch 都实现各自版本，但对上层暴露同一套接口，便于测试与复用。

```swift
public enum ConnectivityError: Error, Sendable {
    case notActivated
    case notReachable
    case sendFailed(underlying: Error?)
    case decodeFailed
}

public protocol ConnectivityEndpoint: Sendable {
    var isReachable: Bool { get }

    /// reachability 变化流（例如 WCSession reachabilityDidChange）
    var reachabilityStream: AsyncStream<Bool> { get }

    /// 收到的消息流（原始 Data 或已解码 Envelope）
    var incomingStream: AsyncStream<Data> { get }

    func activate() async
    func send(_ data: Data) async throws              // realtime
    func transfer(_ data: Data) async                 // eventual delivery (summary)
}
```

**说明**

* `send` 用于 `sendMessage`
* `transfer` 用于 `transferUserInfo`（保证最终可达）

---

### 2.4 编码/解码器（强烈建议集中）

```swift
public protocol SyncCodec: Sendable {
    func encode<T: Codable & Sendable>(_ value: T) throws -> Data
    func decode<T: Codable & Sendable>(_ type: T.Type, from data: Data) throws -> T
}
```

---

## 3. Watch 端：HeartRateService（HealthKit）

```swift
public enum HeartRateAuthorizationStatus: Sendable {
    case notDetermined
    case authorized
    case denied
    case unavailable
}

public enum HeartRateError: Error, Sendable {
    case notAuthorized
    case unavailable
    case sensorError
}

public protocol HeartRateServiceProtocol: Sendable {
    var authorizationStatus: HeartRateAuthorizationStatus { get }

    func requestAuthorization() async -> HeartRateAuthorizationStatus

    /// 开始采集：返回样本流（建议）
    func startStreaming() throws -> AsyncStream<HeartRateSample>

    func stopStreaming()
}
```

**契约说明**

* watch 端唯一负责心率采集
* iOS 若要读 HealthKit，后续另起一个 iOSHeartRateService，不混在本协议里（保持边界）

---

## 4. iOS 端：SessionStore（持久化）

```swift
public enum StoreError: Error, Sendable {
    case writeFailed
    case readFailed
}

public struct SessionRecord: Sendable, Codable, Equatable, Identifiable {
    public var id: UUID
    public var startTime: Date
    public var endTime: Date
    public var pattern: BreathingPattern
    public var durationSec: Int

    public var avgHeartRate: Double?
    public var minHeartRate: Int?
    public var maxHeartRate: Int?
    public var sampleCount: Int
}

public protocol SessionStoreProtocol: Sendable {
    func saveSummary(_ summary: SessionSummary) async throws
    func saveSamples(_ sessionId: UUID, samples: [HeartRateSample]) async throws   // 可选实现
    func fetchAll() async throws -> [SessionRecord]
    func fetch(by id: UUID) async throws -> SessionRecord?
    func delete(id: UUID) async throws
}
```

**MVP 推荐**

* 先实现 `saveSummary` + `fetchAll`
* `saveSamples` 可延后（或只存最近 N 条）

---

## 5. Coordinator（业务编排层）

### 5.1 iOSSessionCoordinator

**职责**：iOS 发起/跟随会话；驱动 engine；与 connectivity/store 协作。

```swift
@MainActor
public protocol iOSSessionCoordinatorProtocol: AnyObject {
    var engine: BreathingEngineProtocol { get }

    func startFromPhone(pattern: BreathingPattern, durationSeconds: Int)
    func pause()
    func resume()
    func stop()

    /// 处理来自 watch 的消息（由 ConnectivityHost 路由）
    func handleIncoming(_ data: Data)
}
```

---

### 5.2 WatchSessionCoordinator

**职责**：watch 发起/跟随会话；启动心率采集；发送消息给 iOS。

```swift
@MainActor
public protocol WatchSessionCoordinatorProtocol: AnyObject {
    var engine: BreathingEngineProtocol { get }

    func startOnWatch(pattern: BreathingPattern, durationSeconds: Int)
    func pause()
    func resume()
    func stop()

    /// 被 iOS 驱动跟随
    func followRemoteStart(sessionId: UUID, pattern: BreathingPattern, durationSeconds: Int, startEpoch: TimeInterval?)
    func handleIncoming(_ data: Data)
}
```

---

## 6. ViewModel（UI 绑定契约，可选但推荐统一）

### 6.1 BreathingViewModel（iOS/watch 通用思想）

```swift
@MainActor
public protocol BreathingViewModelProtocol: ObservableObject {
    var uiState: BreathingEngineState { get }
    var currentBPM: Int? { get }
    var isConnected: Bool { get }

    func onStartTapped()
    func onPauseResumeTapped()
    func onStopTapped()
}
```

---

## 7. 幂等/乱序处理（实现建议接口）

> 幂等过滤建议抽成一个小组件，ConnectivityHost/Client 与 Coordinator 都能复用。

```swift
public protocol SeqFilterProtocol: Sendable {
    mutating func shouldAccept(type: SyncMessageType, seq: Int) -> Bool
}
```

---

## 8. Mock 指南（Testing）

你至少需要这些 mock：

* `MockConnectivityEndpoint`：控制 isReachable、注入 incomingStream、记录 send/transfer
* `MockHeartRateService`：产生可控 bpm 流
* `InMemorySessionStore`：保存 summary 用于测试

---

## 9. 兼容性与演进

* 新增消息 type：只需在 `SyncMessageType` 增加 case，上层 switch 默认忽略未知
* 新增字段：Codable 自动忽略未知字段（需要你使用 JSONDecoder 并保持默认策略）
* 破坏性变更：提升 `version`
